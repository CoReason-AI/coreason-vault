============================= test session starts ==============================
platform linux -- Python 3.12.12, pytest-8.4.2, pluggy-1.6.0
rootdir: /app
configfile: pyproject.toml
testpaths: tests
plugins: cov-5.0.0
collected 53 items

tests/test_additional_edge_cases.py .......                              [ 13%]
tests/test_advanced_scenarios.py ...                                     [ 18%]
tests/test_auth.py ..F....                                               [ 32%]
tests/test_auth_coverage.py .F                                           [ 35%]
tests/test_cipher.py .......                                             [ 49%]
tests/test_complex_cases.py ........                                     [ 64%]
tests/test_config.py FF..                                                [ 71%]
tests/test_edge_cases_new.py ......                                      [ 83%]
tests/test_keeper.py ....                                                [ 90%]
tests/test_manager.py ..                                                 [ 94%]
tests/test_refactor_edge_cases.py ..                                     [ 98%]
tests/test_utils.py .                                                    [100%]

=================================== FAILURES ===================================
__________________________ test_auth_k8s_missing_role __________________________

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9affb1adb0>

    def get_client(self) -> hvac.Client:
        """
        Returns an authenticated Vault client.
        Checks token validity and renews/re-authenticates if necessary.
        Uses a short TTL to avoid checking on every call.
        Thread-safe to prevent concurrent re-authentication.
        """
        # First check (optimistic)
        if self._client is not None and not self._should_validate_token():
            return self._client

        with self._lock:
            # Double-check inside lock
            if self._client is not None and not self._should_validate_token():
                return self._client

            if self._client is None:
                try:
>                   self._client = self._authenticate()
                                   ^^^^^^^^^^^^^^^^^^^^

src/coreason_vault/auth.py:54:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:338: in wrapped_f
    return copy(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:477: in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:378: in iter
    result = action(retry_state)
             ^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:400: in <lambda>
    self._add_action_func(lambda rs: rs.outcome.result())
                                     ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.12/lib/python3.12/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:480: in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9affb1adb0>

    @retry(  # type: ignore[misc]
        retry=retry_if_exception_type((requests.exceptions.RequestException, hvac.exceptions.VaultDown)),
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        reraise=True,
    )
    def _authenticate(self) -> hvac.Client:
        """
        Authenticates to Vault using the configured method.
        Retries on transient network errors.
        """
        try:
            client = hvac.Client(
                url=str(self.config.VAULT_ADDR),
                namespace=self.config.VAULT_NAMESPACE,
                verify=self.config.VAULT_VERIFY_SSL,
            )

            if self.config.VAULT_ROLE_ID and self.config.VAULT_SECRET_ID:
                logger.info("Authenticating to Vault via AppRole")
                client.auth.approle.login(
                    role_id=self.config.VAULT_ROLE_ID,
                    secret_id=self.config.VAULT_SECRET_ID,
                )
            elif self.config.KUBERNETES_SERVICE_ACCOUNT_TOKEN:
                logger.info("Authenticating to Vault via Kubernetes")

                role = self.config.VAULT_K8S_ROLE
                if not role:
                    logger.error("Kubernetes authentication requires a role (set via VAULT_K8S_ROLE)")
>                   raise ValueError("Missing Kubernetes role (VAULT_K8S_ROLE)")
E                   ValueError: Missing Kubernetes role (VAULT_K8S_ROLE)

src/coreason_vault/auth.py:117: ValueError

The above exception was the direct cause of the following exception:

mock_hvac_client = (<MagicMock name='Client' id='140303679236976'>, <MagicMock name='Client()' id='140303679292576'>)

    def test_auth_k8s_missing_role(mock_hvac_client: Any) -> None:
        mock_class, client_instance = mock_hvac_client

        config = CoreasonVaultConfig(
            VAULT_ADDR="http://localhost:8200",
            KUBERNETES_SERVICE_ACCOUNT_TOKEN="jwt-token",
        )
        # Missing role
        config.VAULT_K8S_ROLE = None

        auth = VaultAuthentication(config)
        with pytest.raises(ValueError):
>           auth.get_client()

tests/test_auth.py:73:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9affb1adb0>

    def get_client(self) -> hvac.Client:
        """
        Returns an authenticated Vault client.
        Checks token validity and renews/re-authenticates if necessary.
        Uses a short TTL to avoid checking on every call.
        Thread-safe to prevent concurrent re-authentication.
        """
        # First check (optimistic)
        if self._client is not None and not self._should_validate_token():
            return self._client

        with self._lock:
            # Double-check inside lock
            if self._client is not None and not self._should_validate_token():
                return self._client

            if self._client is None:
                try:
                    self._client = self._authenticate()
                except Exception as e:
                    # Wrap errors from initial auth
                    if isinstance(e, VaultConnectionError):
                        raise
                    logger.error(f"Authentication failed after retries: {e}")
>                   raise VaultConnectionError(f"Vault authentication failed: {e}") from e
E                   coreason_vault.exceptions.VaultConnectionError: Vault authentication failed: Missing Kubernetes role (VAULT_K8S_ROLE)

src/coreason_vault/auth.py:60: VaultConnectionError
----------------------------- Captured stderr call -----------------------------
2026-01-05 09:38:43 | INFO     | coreason_vault.auth:_authenticate:112 - Authenticating to Vault via Kubernetes
2026-01-05 09:38:43 | ERROR    | coreason_vault.auth:_authenticate:116 - Kubernetes authentication requires a role (set via VAULT_K8S_ROLE)
2026-01-05 09:38:43 | ERROR    | coreason_vault.auth:get_client:59 - Authentication failed after retries: Missing Kubernetes role (VAULT_K8S_ROLE)
______________ TestAuthCoverage.test_auth_value_error_propagation ______________

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9aff27aea0>

    def get_client(self) -> hvac.Client:
        """
        Returns an authenticated Vault client.
        Checks token validity and renews/re-authenticates if necessary.
        Uses a short TTL to avoid checking on every call.
        Thread-safe to prevent concurrent re-authentication.
        """
        # First check (optimistic)
        if self._client is not None and not self._should_validate_token():
            return self._client

        with self._lock:
            # Double-check inside lock
            if self._client is not None and not self._should_validate_token():
                return self._client

            if self._client is None:
                try:
>                   self._client = self._authenticate()
                                   ^^^^^^^^^^^^^^^^^^^^

src/coreason_vault/auth.py:54:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:338: in wrapped_f
    return copy(f, *args, **kw)
           ^^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:477: in __call__
    do = self.iter(retry_state=retry_state)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:378: in iter
    result = action(retry_state)
             ^^^^^^^^^^^^^^^^^^^
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:400: in <lambda>
    self._add_action_func(lambda rs: rs.outcome.result())
                                     ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.12/lib/python3.12/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/home/jules/.pyenv/versions/3.12.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/home/jules/.cache/pypoetry/virtualenvs/coreason-vault-9TtSrW0h-py3.12/lib/python3.12/site-packages/tenacity/__init__.py:480: in __call__
    result = fn(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9aff27aea0>

    @retry(  # type: ignore[misc]
        retry=retry_if_exception_type((requests.exceptions.RequestException, hvac.exceptions.VaultDown)),
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        reraise=True,
    )
    def _authenticate(self) -> hvac.Client:
        """
        Authenticates to Vault using the configured method.
        Retries on transient network errors.
        """
        try:
            client = hvac.Client(
                url=str(self.config.VAULT_ADDR),
                namespace=self.config.VAULT_NAMESPACE,
                verify=self.config.VAULT_VERIFY_SSL,
            )

            if self.config.VAULT_ROLE_ID and self.config.VAULT_SECRET_ID:
                logger.info("Authenticating to Vault via AppRole")
                client.auth.approle.login(
                    role_id=self.config.VAULT_ROLE_ID,
                    secret_id=self.config.VAULT_SECRET_ID,
                )
            elif self.config.KUBERNETES_SERVICE_ACCOUNT_TOKEN:
                logger.info("Authenticating to Vault via Kubernetes")

                role = self.config.VAULT_K8S_ROLE
                if not role:
                    logger.error("Kubernetes authentication requires a role (set via VAULT_K8S_ROLE)")
                    raise ValueError("Missing Kubernetes role (VAULT_K8S_ROLE)")

                client.auth.kubernetes.login(
                    role=role,
                    jwt=self.config.KUBERNETES_SERVICE_ACCOUNT_TOKEN,
                )
            else:
                logger.error("No valid authentication method found in configuration")
>               raise ValueError("Missing authentication credentials (AppRole or Kubernetes)")
E               ValueError: Missing authentication credentials (AppRole or Kubernetes)

src/coreason_vault/auth.py:125: ValueError

The above exception was the direct cause of the following exception:

self = <test_auth_coverage.TestAuthCoverage object at 0x7f9afefd3440>

    def test_auth_value_error_propagation(self) -> None:
        """
        Cover lines 105-106: except ValueError: raise.
        We need to trigger a ValueError inside _authenticate logic that is NOT one of the explicit raises.
        Or just ensure one of the explicit raises is caught and re-raised by that specific block.

        The code has:
        try:
          ...
          if ... raise ValueError("Missing Kubernetes role")
          else ... raise ValueError("Missing authentication credentials")
        except ValueError:
          raise

        Any of those raises will hit the except block.
        We just need to ensure we exercise one of them.
        `test_auth_k8s_missing_role` does this.
        Why did coverage report it missing?
        Maybe `pytest --cov` sometimes misses simple `raise` lines?
        Let's explicitly test the "No valid authentication method" path (else block) to be sure.
        """
        config = CoreasonVaultConfig(
            VAULT_ADDR="http://localhost:8200",
            # No Auth credentials provided
        )

        auth = VaultAuthentication(config)

        with pytest.raises(ValueError) as exc:
>           auth.get_client()

tests/test_auth_coverage.py:112:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <coreason_vault.auth.VaultAuthentication object at 0x7f9aff27aea0>

    def get_client(self) -> hvac.Client:
        """
        Returns an authenticated Vault client.
        Checks token validity and renews/re-authenticates if necessary.
        Uses a short TTL to avoid checking on every call.
        Thread-safe to prevent concurrent re-authentication.
        """
        # First check (optimistic)
        if self._client is not None and not self._should_validate_token():
            return self._client

        with self._lock:
            # Double-check inside lock
            if self._client is not None and not self._should_validate_token():
                return self._client

            if self._client is None:
                try:
                    self._client = self._authenticate()
                except Exception as e:
                    # Wrap errors from initial auth
                    if isinstance(e, VaultConnectionError):
                        raise
                    logger.error(f"Authentication failed after retries: {e}")
>                   raise VaultConnectionError(f"Vault authentication failed: {e}") from e
E                   coreason_vault.exceptions.VaultConnectionError: Vault authentication failed: Missing authentication credentials (AppRole or Kubernetes)

src/coreason_vault/auth.py:60: VaultConnectionError
----------------------------- Captured stderr call -----------------------------
2026-01-05 09:38:43 | ERROR    | coreason_vault.auth:_authenticate:124 - No valid authentication method found in configuration
2026-01-05 09:38:43 | ERROR    | coreason_vault.auth:get_client:59 - Authentication failed after retries: Missing authentication credentials (AppRole or Kubernetes)
_____________________________ test_config_defaults _____________________________

    def test_config_defaults() -> None:
        """Test that default values are set correctly."""
        with patch.dict(os.environ, {"VAULT_ADDR": "http://localhost:8200"}, clear=True):
            config = CoreasonVaultConfig()  # type: ignore[call-arg, unused-ignore]
>           assert config.VAULT_ADDR == "http://localhost:8200"
E           AssertionError: assert HttpUrl('http://localhost:8200/') == 'http://localhost:8200'
E            +  where HttpUrl('http://localhost:8200/') = CoreasonVaultConfig(VAULT_ADDR=HttpUrl('http://localhost:8200/'), VAULT_NAMESPACE=None, VAULT_ROLE_ID=None, VAULT_SECR...OLE=None, KUBERNETES_SERVICE_ACCOUNT_TOKEN=None, VAULT_MOUNT_POINT='secret', VAULT_VERIFY_SSL=True, VAULT_TOKEN_TTL=60).VAULT_ADDR

tests/test_config.py:24: AssertionError
__________________________ test_config_env_overrides ___________________________

    def test_config_env_overrides() -> None:
        """Test that environment variables override defaults."""
        env_vars = {
            "VAULT_ADDR": "https://vault.example.com",
            "VAULT_MOUNT_POINT": "custom_secret",
            "VAULT_VERIFY_SSL": "false",
            "VAULT_NAMESPACE": "admin",
            "VAULT_K8S_ROLE": "test-role",
        }
        with patch.dict(os.environ, env_vars, clear=True):
            config = CoreasonVaultConfig()  # type: ignore[call-arg, unused-ignore]
>           assert config.VAULT_ADDR == "https://vault.example.com"
E           AssertionError: assert HttpUrl('https://vault.example.com/') == 'https://vault.example.com'
E            +  where HttpUrl('https://vault.example.com/') = CoreasonVaultConfig(VAULT_ADDR=HttpUrl('https://vault.example.com/'), VAULT_NAMESPACE='admin', VAULT_ROLE_ID=None, VAU..., KUBERNETES_SERVICE_ACCOUNT_TOKEN=None, VAULT_MOUNT_POINT='custom_secret', VAULT_VERIFY_SSL=False, VAULT_TOKEN_TTL=60).VAULT_ADDR

tests/test_config.py:41: AssertionError
=========================== short test summary info ============================
FAILED tests/test_auth.py::test_auth_k8s_missing_role - coreason_vault.except...
FAILED tests/test_auth_coverage.py::TestAuthCoverage::test_auth_value_error_propagation
FAILED tests/test_config.py::test_config_defaults - AssertionError: assert Ht...
FAILED tests/test_config.py::test_config_env_overrides - AssertionError: asse...
======================== 4 failed, 49 passed in 13.25s =========================
